# âš¡ Braun Multiplier (4x4 Carry-Save Array Multiplier)

A **gate-level Verilog implementation** of a 4x4 Braun Multiplier using the **carry-save array architecture**. This project demonstrates how arithmetic circuits are built from scratch using fundamental logic gates and modular design principles.

Built entirely using **structural modeling** â€” no behavioral constructs.

---

## ğŸ§  What is a Braun Multiplier?

The Braun Multiplier is a **parallel array multiplier** that performs unsigned multiplication using:
* Partial product generation using AND gates
* Carry-save addition for intermediate results
* Final carry-propagate addition for the output

It's a foundational circuit in digital design, commonly used in:
* Arithmetic Logic Units (ALUs)
* Digital Signal Processing (DSP)
* Hardware accelerators

---

## ğŸ¯ Project Goals

This project was built to:
* Understand how arithmetic circuits are constructed from basic logic gates
* Learn carry propagation and modular design using simple building blocks
* Gain hands-on experience with **gate-level Verilog modeling**
* Practice systematic testing and verification using testbenches

**Note:** Gate-level modeling is not preferred for large systems, but it provides **maximum visibility into logic flow** â€” ideal for learning.

---

## âœ¨ Features

* ğŸ”¹ Fully structural, gate-level design
* ğŸ”¹ Modular architecture (Half Adder â†’ Full Adder â†’ Multiplier)
* ğŸ”¹ Comprehensive testbenches for each module
* ğŸ”¹ Waveform outputs for visual verification
* ğŸ”¹ Exhaustive testing (all 256 input combinations for 4x4 multiplication)

---

## ğŸ—ï¸ Design Architecture

### Layered Development Approach

```
Half Adder (HA)
    â†“ (tested independently)
Full Adder (FA) â€” built using 2 HAs
    â†“ (tested independently)
4x4 Braun Multiplier (BM) â€” built using cascaded FAs
    â†“ (tested with all input combinations)
Complete Verified Design
```

### Block Diagram

```
    A[3:0] Ã— B[3:0]
         â†“
   Partial Products (AND gates)
         â†“
   Carry-Save Array (Full Adders)
         â†“
   Final Addition Layer
         â†“
    P[7:0] (8-bit Product)
```

---

## ğŸ“‚ Project Structure

```
.
â”œâ”€â”€ HA.v                    # Half Adder module
â”œâ”€â”€ HA_tb.v                 # Half Adder testbench
â”œâ”€â”€ FA.v                    # Full Adder module (built using HAs)
â”œâ”€â”€ FA_tb.v                 # Full Adder testbench
â”œâ”€â”€ BM.v                    # 4x4 Braun Multiplier (top module)
â”œâ”€â”€ BM_tb.v                 # Braun Multiplier testbench
â”œâ”€â”€ HA_waveform.png         # Half Adder simulation waveform
â”œâ”€â”€ FA_waveform.png         # Full Adder simulation waveform
â””â”€â”€ BM_waveform.png         # Multiplier simulation waveform
```

---

## ğŸ”§ Modules Overview

### 1. Half Adder (HA)
* **Inputs:** `a`, `b`
* **Outputs:** `sum`, `carry`
* **Logic:** Pure gate-level using XOR and AND gates

### 2. Full Adder (FA)
* **Inputs:** `a`, `b`, `cin`
* **Outputs:** `sum`, `cout`
* **Implementation:** Built using 2 Half Adders and 1 OR gate

### 3. 4x4 Braun Multiplier (BM)
* **Inputs:** `A[3:0]`, `B[3:0]` (two 4-bit unsigned numbers)
* **Output:** `P[7:0]` (8-bit product)
* **Implementation:** Array of Full Adders processing partial products

---

## ğŸš€ How to Run

### Option 1: Using EDA Playground (Recommended)

1. Go to [EDA Playground](https://www.edaplayground.com/)
2. Copy the module code into the left panel
3. Copy the testbench code into the right panel
4. Select **Icarus Verilog 12.0** as the simulator
5. Enable **EPWave** for waveform viewing
6. Click **Run**

**Pro Tips:**
* Go to Settings â†’ Enable "Open waveform in new tab"
* Expand code windows for better visibility
* Make sure `$dumpfile` and `$dumpvars` are present in the testbench

### Option 2: Using Local Simulator

```bash
# Compile and simulate using Icarus Verilog
iverilog -o output HA.v HA_tb.v
vvp output

# View waveform using GTKWave
gtkwave dump.vcd
```

---

## ğŸ§ª Testing Strategy

### Half Adder Testing
* All 4 input combinations tested
* Verified sum and carry outputs

### Full Adder Testing
* All 8 input combinations tested
* Verified correct carry propagation

### Braun Multiplier Testing
* **Exhaustive testing:** All 256 combinations (0Ã—0 to 15Ã—15)
* Outputs monitored using `$monitor`
* Waveforms captured for visual verification

Example test cases:
```
0000 Ã— 0000 = 00000000
0101 Ã— 0011 = 00001111 (5 Ã— 3 = 15)
1111 Ã— 1111 = 11100001 (15 Ã— 15 = 225)
```

---

## ğŸ“Š Simulation Results

All modules were tested independently before integration:

* âœ… **Half Adder:** Correct sum and carry generation
* âœ… **Full Adder:** Proper carry propagation
* âœ… **Braun Multiplier:** Accurate 4x4 multiplication for all inputs

Waveform screenshots are included in the repository for verification.

---

## ğŸ› ï¸ Development Tools

### Recommended Setup
* **Code Editor:** Visual Studio Code
* **Extension:** Verilog-HDL/SystemVerilog (for syntax highlighting)
* **Simulator:** Icarus Verilog / EDA Playground
* **Waveform Viewer:** EPWave / GTKWave

---

## ğŸ“Œ Key Learnings

* Understanding arithmetic circuit design from first principles
* Building complex modules from simple building blocks (bottom-up approach)
* Gate-level modeling and structural instantiation in Verilog
* Systematic testing and verification methodology
* Carry propagation in array multipliers
* Modular design for hardware systems

---

## ğŸ“ Educational Value

This project is perfect for:
* Students learning digital logic design
* Understanding how multiplication is implemented in hardware
* Learning Verilog structural modeling
* Practicing testbench development and waveform analysis

**Why gate-level?**
While not used in modern industrial designs, gate-level modeling provides:
* Complete visibility into logic operations
* Understanding of data paths and signal flow
* Foundation for more complex RTL designs

---

## ğŸ”® Future Enhancements

Possible extensions to this project:
* Implement 8x8 or 16x16 multipliers
* Add signed multiplication support (Booth's algorithm)
* Compare with behavioral model for verification
* Synthesize design and analyze area/delay trade-offs
* Implement Wallace Tree multiplier for comparison

---

## ğŸ‘¨â€ğŸ’» Author

**Adarsh Akshat**
* B.Tech in Electrical and Electronics Engineering, NITK
* GitHub: [@aadiakshat](https://github.com/aadiakshat)

---

## ğŸ“ License

MIT License - Feel free to use this for learning and educational purposes.

---

## ğŸ¤ Contributing

Suggestions and improvements are welcome! Feel free to:
* Report issues
* Suggest optimizations
* Share educational resources

---

## ğŸ“š References

* Digital Design and Computer Architecture by Harris & Harris
* Verilog HDL: A Guide to Digital Design and Synthesis by Samir Palnitkar
* VLSI Digital Signal Processing Systems by Keshab K. Parhi
